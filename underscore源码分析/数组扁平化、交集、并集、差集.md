# 前言
学习的[underscore.js](https://github.com/jashkenas/underscore) 源码版本为1.13.1

# 数组的扁平化

## 如何实现数组的扁平化?
### 1. 利用ES6的flat方法   
ES6中数组新增了flat方法，会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。    
其中参数表示想要拉平的层数，默认为1。如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。   
```js
var arr = [1, 2, [3, [4, 5, [6]]]];

arr.flat();    // [1, 2, 3, [4, 5, [6]]]

arr.flat(2);    // [1, 2, 3, 4, 5, [6]]

arr.flat(Infinity);   // [1, 2, 3, 4, 5, 6]

var arr1 = [1, 2, , 4, 5];
// 会将empty元素过滤掉
arr1.flat();  // [1, 2, 4, 5]

```
### 2. 利用栈/队列 + ES6 拓展运算符  
```js
// 也可以使用shift/unshift, 但使用pop/push速度更快
function flatten(input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) {
      stack.push(...next);
    } else {
      res.push(next);
    }
  }
  // 反转
  return res.reverse();
}
```

测试下：
```js
// 利用underscore中range函数创建整数灵活编号的列表
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}

// 使用shift/unshift
function flatten1(input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    const next = stack.shift();
    if (Array.isArray(next)) {
      stack.unshift(...next);
    } else {
      res.push(next);
    }
  }
  return res;
}

var arr = range(10000);
// 需要扁平化的数组
var list = [arr, [arr], [arr, [arr]]]

console.time('使用pop/push耗时');
flatten(list)
console.timeEnd('使用pop/push耗时');


console.time('使用shift/unshift耗时');
flatten1(list)
console.timeEnd('使用shift/unshift耗时');
```
![测试结果](https://img-blog.csdnimg.cn/d22ee2128a1c40f08669f588bb609936.png)   
或者使用下面代码：    
```js
var arr = [1, 2, [3, [4, 5, [6]]]];
function flatten(arr) {
  while (arr.some(Array.isArray)) {
    arr = [].concat(...arr);
  }
  return arr;
}
flatten(arr);  // [1, 2, 3, 4, 5, 6] 
```
### 3. 使用reduce + concat + 递归  
```js
var arr = [1, 2, [3, [4, 5, [6]]]];
function flatten(arr, deep){
  return deep > 0 ? arr.reduce((prev, next) => prev.concat(Array.isArray(next) ? flatten(next, deep - 1) : next), []) : arr.slice();
}
flatten(arr, Infinity);  // [1, 2, 3, 4, 5, 6]     
```
### 4. 使用Generator函数
```js
function* flatten(array, depth) {
  if (depth === undefined) {
    depth = 1;
  }

  for (const item of array) {
    if (Array.isArray(item) && depth > 0) {
      yield* flatten(item, depth - 1);
    } else {
      yield item;
    }
  }
}

const arr = [1, 2, [3, 4, [5, 6]]];
const flattened = [...flatten(arr, Infinity)];
// [1, 2, 3, 4, 5, 6]
```
### 5. 使用toString + split方法（<font color="red">只适用于都是数字组成的数组，不推荐</font>）
```js
var arr = [1, 2, [3, [4, 5, [6]]]];
function flatten(arr){
    return arr.toString().split(',')
}
console.log(flatten(arr));
```
### 6. 正则（<font color="red">不推荐</font>）
```js
function flatten(arr) {
  let str = JSON.stringify(arr);
  str = str.replace(/(\[|\])/g, '');
  str = '[' + str + ']';
  return JSON.parse(str); 
}
```
## underscore.js中的_.flatten(array, [shallow])
先来看使用效果： 

```js
var list = [1, [2], [3, [[[4]]]]];
_.flatten(list);  // [1, 2, 3, 4]

// shallow为true则数组将只减少一维的嵌套
_.flatten(list, true);  // [1, 2, 3, [4]]

// 处理arguments
var result = (function(){ return _.flatten(arguments); }(1, [2], [3, [[[4]]]]));
console.log(result);  // [1, 2, 3, 4]

_.flatten([[1,2,3], [4, 5, 6], 5, 1, 3], true);  // [1, 2, 3, 4, 5, 6, 5, 1, 3]
```
如何实现？
```js
/**
 * 
 * @param {array|arguments} input 需要展开的数组或arguments
 * @param {?boolean|number} depth 
 * @param {?boolean} strict strict === true，通常和 depth === true 配合使用 表示只展开一层，但是不保存非数组元素（即无法展开的基础类型）
 * @param {?array} output 输出结果
 */
function flatten$1(input, depth, strict, output) {
  output = output || [];
  // depth为undefined、false
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = input.length; i < length; i++) {
    var value = input[i];
    // 数组 或者 arguments且length 属性值是不大于 Number.MAX_SAFE_INTEGER 的自然数
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      if (depth > 1) {
        // 递归展开
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0,
          len = value.length;
        // 将 value 数组的元素添加到 output 数组中
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

function flatten(array, depth) {
  return flatten$1(array, depth, false);
}
```

# 数组的交集（去重）
[LeedCode 349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)   
获取两数组的交集（去重）  
```js
var intersection = function(nums1, nums2) {
  return [...new Set(nums1.filter((num) => nums2.includes(num)))]
};
```
underscore中是使用intersection方法进行获取数组交集   
_.intersection(*arrays)   
返回传入 arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里。   
```js
_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);   // [1, 2]
```

实现： 
```js
// 获取一个对象上自有属性（不包括原型链上的）的 values 值
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}

/**
 * 如果obj包含指定的item则返回true（使用===检测）。如果obj 是数组，内部使用indexOf判断。使用fromIndex来给定开始检索的索引位置。
 * @param {array|object} obj 
 * @param {*} item 包含项
 * @param {*} fromIndex  开始检索的索引位置
 * @param {*} guard 
 */
function contains(obj, item, fromIndex, guard) {
  // 如果是对象，返回 values 组成的数组
  if (!isArrayLike(obj)) obj = values(obj);
  // 如果没有指定该参数，则默认从头找起
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  // 使用indexOf寻找
  return indexOf(obj, item, fromIndex) >= 0;
}

// 返回传入 arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里
// 注意： 结果为去重的
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = array.length; i < length; i++) {
    var item = array[i];
    // 返回的 result 是去重的
    if (contains(result, item)) continue;
    var j;
    // 判断其他参数数组中是否都有 item 这个元素
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}
```


# 数组的并集
_.union(*arrays)   
返回传入的 arrays（数组）并集：按顺序返回，返回数组的元素是唯一的，可以传入一个或多个 arrays （数组)   
```js
_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);    // [1, 2, 3, 101, 10]
```
如何实现？   

# 数组的差集
_.difference(array, *others)   
返回的值来自array参数数组，并且不存在于other 数组   
```js
_.difference([1, 2, 3, 4, 5], [5, 2, 10]);    // [1, 3, 4]
```


参考资料：   
https://github.com/lessfish/underscore-analysis/issues/10   